// Generated by CoffeeScript 1.4.0
(function() {
  var CSBuilder, JSBuilder, JadeBuilder, StylusBuilder, async, buildFactory, config, exec, fileConfig, fs, logger, path, util, walk, _,
    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  path = require('path');

  fs = require('fs');

  util = require('util');

  async = require('async');

  _ = require('lodash');

  exec = require('child_process').exec;

  logger = require('./loggers').get('util');

  walk = require('./finder').walk;

  CSBuilder = require('./CSBuilder');

  JSBuilder = require('./JSBuilder');

  JadeBuilder = require('./JadeBuilder');

  StylusBuilder = require('./StylusBuilder');

  config = {
    src: 'src',
    out: '.',
    clone: [],
    mappings: [],
    coffee: {},
    jade: {
      amd: true
    },
    stylus: {
      url: ['public'],
      paths: ['public/images']
    }
  };

  if (fs.existsSync('squid.json')) {
    fileConfig = JSON.parse(fs.readFileSync('squid.json'));
    config = _(fileConfig).defaults(config);
  }

  if (config.post_build) {
    config.post_build.match = new RegExp(config.post_build.match);
  }

  config.clone.forEach(function(clone) {
    return clone.match = new RegExp(clone.match);
  });

  buildFactory = {
    get: function(file) {
      return this[path.extname(file)];
    },
    '.coffee': new CSBuilder(config),
    '.js': new JSBuilder(config),
    '.styl': new StylusBuilder(config),
    '.jade': new JadeBuilder(config)
  };

  module.exports = {
    buildAll: function(opts, cb) {
      var filter,
        _this = this;
      if (opts == null) {
        opts = {};
      }
      if (typeof opts === 'function') {
        cb = opts;
        opts = {};
      }
      cb || (cb = function(errors) {
        var e, _i, _len, _results;
        if (errors) {
          _results = [];
          for (_i = 0, _len = errors.length; _i < _len; _i++) {
            e = errors[_i];
            _results.push(logger.error(e.toString()));
          }
          return _results;
        } else {
          return logger.info("Build done.");
        }
      });
      filter = function(f, stat) {
        var _ref;
        if (stat.isDirectory() && (opts.except && (_ref = path.basename(f), __indexOf.call(opts.except, _ref) >= 0))) {
          return false;
        }
        if (stat.isDirectory()) {
          return true;
        }
        return /\.(coffee|js|styl|jade)$/.test(f);
      };
      return walk(config.src, filter, function(err, files) {
        if (err) {
          return logger.error(err);
        }
        return _this.liveBuildAll(files, cb);
      });
    },
    removeBuild: function(file, cb) {
      return buildFactory.get(file).removeBuild(file, cb);
    },
    liveBuild: function(src, cb) {
      return buildFactory.get(src).build(src, true, function(err, file, message) {
        var p;
        cb(err, file, message);
        if (!err && !/identical/.test(message) && config.post_build && config.post_build.match.test(src)) {
          console.log("post-build...");
          if (p = config.post_build.process) {
            p.kill();
          }
          return config.post_build.process = exec(config.post_build.cmd, function() {
            return config.post_build.process = null;
          });
        }
      });
    },
    liveBuildAll: function(fileItems, cb) {
      var buildFile, builder, code, errors, file, files, _i, _len;
      files = (function() {
        var _results;
        _results = [];
        for (file in fileItems) {
          _results.push(file);
        }
        return _results;
      })();
      logger.debug('scan all ...');
      for (_i = 0, _len = files.length; _i < _len; _i++) {
        file = files[_i];
        if (builder = buildFactory.get(file)) {
          code = fs.readFileSync(file, 'utf8');
          builder.scan(file, code);
        }
      }
      errors = [];
      buildFile = function(file, cb) {
        builder = buildFactory.get(file);
        if (!builder) {
          return cb(null);
        }
        return builder.build(file, false, function(err) {
          if (err) {
            errors.push(err);
          }
          return cb(null);
        });
      };
      return async.forEach(files, buildFile, function() {
        if (errors.length) {
          return cb(errors);
        } else {
          return cb(null);
        }
      });
    }
  };

}).call(this);
